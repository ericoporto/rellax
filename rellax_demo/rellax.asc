// Rellax
// 0.1.4
// A module to provide smooth scrolling and parallax!
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Before starting, you must create the following Custom Properties
// in AGS Editor, for usage with Objects.
// Just click on Properties [...] and on the Edit Custom Properties screen,
// click on Edit Schema ... button, and add the two properties below:
//
// PxPos:
//    Name: PxPos
//    Description: Object's horizontal parallax
//    Type: Number
//    Default Value: 0
//
// PyPos:
//    Name: PyPos
//    Description: Object's vertical parallax
//    Type: Number
//    Default Value: 0
//
//  The number defined on Px or Py will be divided by 100 and used to increase
// the scrolling. An object with Px and Py 0 is scrolled normally, an object
// with Px and Py 100 will be fixed on the screen despite camera movement.
//
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//
// based on Smooth Scrolling + Parallax Module
// by Alasdair Beckett, based on code by Steve McCrea.
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
#define MAX_PARALLAX_OBJS 39

// Custom properties for objects
// PxPos: horizontal parallax
// PyPos: vertical parallax

// Target character for camera tracking
Character* _TargetCharacter;
Point* _TargetPos;

// Parallax objects
Object* _pxo[MAX_PARALLAX_OBJS];
int _pxoRoomStartX[MAX_PARALLAX_OBJS];
int _pxoRoomStartY[MAX_PARALLAX_OBJS];
int _pxoOriginX[MAX_PARALLAX_OBJS];
int _pxoOriginY[MAX_PARALLAX_OBJS];
int _pxo_count;

// Camera window dimensions
int _cam_window_w, _cam_window_h;

// Scrolling
float _scroll_x,  _scroll_y;
float _next_cam_x, _next_cam_y;

// Previous character position
int _prev_c_x, _prev_c_y;

// Camera offsets
int _off_x, _off_y;
int _look_ahead_x;
int _look_ahead_y;
int _standstill_ticks_y;

// Interpolation factors
float _cam_lerp_factor_x;
float _cam_lerp_factor_y;
float _y_multiplier;

// Current camera position
float _cam_x, _cam_y;

// Partial character height
int _partial_c_height;

// Number of ticks for standing still
int _count_still_ticks;

// Flags
bool _is_doRoomSetup;
bool _DebugShow;
bool _SmoothCamEnabled = true;
bool _ParallaxEnabled = true;
bool _AdjustCameraOnRoomLoad = true;


// Debugging objects
DynamicSprite* _debug_spr;
Overlay* _debug_ovr;

// Linear interpolation
float _Lerp(float from, float to, float t) {
  return (from + (to - from) * t);
}

// Clamp integer value between min and max
int _ClampInt(int value, int min, int max) {
  if (value > max) return max;
  else if (value < min) return min;
  return value;
}

float _ClampFloat(float value, float min, float max) {
  if (value > max) return max;
  else if (value < min) return min;
  return value;
}

void _drawClearRectangle(DrawingSurface* surf, int x1, int y1, int x2, int y2)
{
  surf.DrawLine(x1, y1, x2, y1);
  surf.DrawLine(x2, y1, x2, y2);
  surf.DrawLine(x1, y2, x2, y2);
  surf.DrawLine(x1, y1, x1, y2);
}

// -- HELPER FUNCTIONS --

void _enable_parallax(bool enable) { 
  _ParallaxEnabled = enable;
}

void _update_target_height()
{
  ViewFrame* c_vf = Game.GetViewFrame(_TargetCharacter.NormalView, 0, 0);  
  float scaling = IntToFloat(_TargetCharacter.Scaling)/100.00;
  _partial_c_height = FloatToInt((IntToFloat(Game.SpriteHeight[c_vf.Graphic])*scaling)/3.0);  
}

void _set_targetcharacter(Character* target) {
  if(target.Room <= 0 && player.Room != target.Room) {
    if(_DebugShow) AbortGame("Target character must be at the same room as the player character");
    return;
  }
  
  _TargetCharacter = target;
  _update_target_height();
}

void _updateCameras()
{  
  _next_cam_x = IntToFloat(Game.Camera.X);
  _next_cam_y = IntToFloat(Game.Camera.Y);
  _cam_x = _next_cam_x;
  _cam_y = _next_cam_y;
}

void doObjectParallax(){
  int camx = FloatToInt(_next_cam_x);
  int camy = FloatToInt(_next_cam_y);

  for(int i=0; i<_pxo_count; i++){
    if(_pxo[i].GetProperty("PxPos") !=0 || _pxo[i].GetProperty("PyPos") != 0) {
      float parallax_x = IntToFloat(_pxo[i].GetProperty("PxPos"))/100.0;
      float parallax_y = IntToFloat(_pxo[i].GetProperty("PyPos"))/100.0;

      _pxo[i].X=_pxoOriginX[i]+FloatToInt(IntToFloat(camx)*parallax_x);
      _pxo[i].Y=_pxoOriginY[i]+FloatToInt(IntToFloat(camy)*parallax_y);
    }
  }
}

void _enable_smoothcam(bool enable) {
  if(enable == true){
    doObjectParallax();
  }

  _updateCameras();
  _SmoothCamEnabled = enable;  
}

// -- MOST RELEVANT FUNCTIONS --

void _rellax_defaults()
{  
  _cam_window_w = 64;
  _cam_window_h = 40;
  _look_ahead_x = 20;
  _look_ahead_y = 16;
  _standstill_ticks_y = 0;
  _cam_lerp_factor_x = 0.01;
  _cam_lerp_factor_y = 0.01;
  _set_targetcharacter(player);
  _enable_parallax(true);
  _enable_smoothcam(true);
}

Point* _getTargetFocus()
{
  Point* focus = new Point;
    
  switch(_TargetCharacter.Loop)
  {
    case 0: focus.y = _look_ahead_y; break; // down
    case 1: focus.x = -_look_ahead_x; break; // left
    case 2: focus.x = _look_ahead_x; break; // right
    case 3: focus.y = -_look_ahead_y; break; // up
    case 4: if(_TargetCharacter.DiagonalLoops) {focus.y = 2*_look_ahead_y/3; focus.x = 2*_look_ahead_x/3;} break; // down-right
    case 5: if(_TargetCharacter.DiagonalLoops) {focus.y = -2*_look_ahead_y/3; focus.x = 2*_look_ahead_x/3;} break; // up-right
    case 6: if(_TargetCharacter.DiagonalLoops) {focus.y = 2*_look_ahead_y/3; focus.x = -2*_look_ahead_x/3;} break; // down-left
    case 7: if(_TargetCharacter.DiagonalLoops) {focus.y = -2*_look_ahead_y/3; focus.x = -2*_look_ahead_x/3;} break; // up-left
  }
      
  return focus;
}

float _getStandstillMultiplier()
{
  float multiplier = 1.0;
  if(_standstill_ticks_y > 0) {
    if(_count_still_ticks <= _standstill_ticks_y) multiplier = IntToFloat(_count_still_ticks)*0.138 ;
    if(_count_still_ticks > _standstill_ticks_y) {
      multiplier = 5.0;
      _count_still_ticks = _standstill_ticks_y + 6;
    }
  }
  return multiplier;
}

// Perform camera tracking, returning a desired camera position
Point* _doCameraTracking()
{  
  // If the character hasn't moved, increment the counter for still ticks
  if(_prev_c_x == _TargetPos.x && _prev_c_y == _TargetPos.y)
    if(_standstill_ticks_y != 0) _count_still_ticks++;
  else // Otherwise, reset the counter
    _count_still_ticks = 0;

  Point* cam_target = new Point;
  Point* focus = _getTargetFocus();
  cam_target.x = _TargetPos.x + focus.x;
  cam_target.y = _TargetPos.y + focus.y;

  bool is_outside_cam_window = cam_target.x-Game.Camera.Width/2-Game.Camera.X<=-_cam_window_w/2 ||
     cam_target.x-Game.Camera.Width/2-Game.Camera.X>_cam_window_w/2 ||
     cam_target.y-Game.Camera.Height/2-Game.Camera.Y<=-_cam_window_h/2 ||
     cam_target.y-Game.Camera.Height/2-Game.Camera.Y>_cam_window_h/2;

  if(is_outside_cam_window || (_count_still_ticks > 5 )){
    _y_multiplier = _getStandstillMultiplier();
                      
    cam_target.x = _ClampInt(cam_target.x + _off_x - Game.Camera.Width/2, 
                  0, Room.Width-Game.Camera.Width);                          
    cam_target.y = _ClampInt(cam_target.y + _off_y - Game.Camera.Height/2,
                  0, Room.Height-Game.Camera.Height);
  } else {
    // the camera is inside the window, this means we don't want it to move
    cam_target.x = Game.Camera.X;
    cam_target.y = Game.Camera.Y;
  }

  _prev_c_x = _TargetPos.x;
  _prev_c_y = _TargetPos.y;
  return cam_target;
}

// debug helper function
void _drawDebugOverlay()
{
  if(_debug_spr == null) 
    return;
  
  DrawingSurface* surf = _debug_spr.GetDrawingSurface();
  surf.Clear();
  
  // Calculate screen coordinates for camera and target character positions, in rellax terms
  Point* cam_pos = Screen.Viewport.RoomToScreenPoint(Game.Camera.Width/2+Game.Camera.X, Game.Camera.Height/2+Game.Camera.Y, false);
  Point* target_pos = Screen.Viewport.RoomToScreenPoint(_TargetCharacter.x, _TargetCharacter.y, false);
  
  surf.DrawingColor = 63811; // red
  
  // Draw rectangle of the camera window
  _drawClearRectangle(surf, 
                      cam_pos.x - _cam_window_w/2, cam_pos.y - _cam_window_h/2, 
                      cam_pos.x + _cam_window_w/2, cam_pos.y + _cam_window_h/2);
  
  // Draw line in direction that target character is facing, length matches look ahead
  Point* focus = _getTargetFocus();
  surf.DrawLine(target_pos.x, target_pos.y, target_pos.x + focus.x, target_pos.y + focus.y);
  
  surf.DrawString(20, 20, eFontNormal, "Standstill: %d", _count_still_ticks);
  
  surf.Release();
  
  if (_debug_ovr != null) {
    _debug_ovr.Remove();
    _debug_ovr = null;
  }
  
  _debug_ovr = Overlay.CreateGraphical(0, 0, _debug_spr.Graphic, true);
}

void _quickAdjustToTarget()
{
  Point* p = _doCameraTracking();
  
  _next_cam_x = IntToFloat(p.x);
  _next_cam_y = IntToFloat(p.y);
  _cam_x = _next_cam_x;
  _cam_y = _next_cam_y;
  
  Game.Camera.SetAt(p.x, p.y);
}

void doSmoothCameraTracking()
{
  Point* p = _doCameraTracking();

  if(p.x != Game.Camera.X || p.y != Game.Camera.Y) {
    if(_cam_lerp_factor_x > 0.04 && _cam_lerp_factor_y > 0.04) {
      _next_cam_x = _Lerp(_cam_x, IntToFloat(p.x), _cam_lerp_factor_x);
      _next_cam_y = _Lerp(_cam_y, IntToFloat(p.y), _cam_lerp_factor_y*_y_multiplier);
    } else {
      float d_x = _ClampFloat( Maths.Sqrt((_cam_x-IntToFloat(p.x))*(_cam_x-IntToFloat(p.x))/4.0), 1.0, 8.0);
      float d_y = _ClampFloat( Maths.Sqrt((_cam_y-IntToFloat(p.y))*(_cam_y-IntToFloat(p.y))/4.0), 1.0, 8.0);
      
      float clfx = 0.4/d_x;
      float clfy = 0.4/d_y; 
      
      _next_cam_x = _Lerp(_cam_x, IntToFloat(p.x), clfx);
      _next_cam_y = _Lerp(_cam_y, IntToFloat(p.y), clfy);
    }
  }
}
  
void _enable_debug_overlay(bool enable)
{
  if (!enable && _debug_ovr != null) {
    _debug_ovr.Remove();
    _debug_ovr = null;
  }
  
  if (_debug_spr != null) {
    _debug_spr.Delete();
    _debug_spr = null;
  } 
  
  if(enable) { 
    _debug_spr = DynamicSprite.Create(Screen.Width, Screen.Height, true);    
  }
  
  _DebugShow = enable;
}

// ---- Rellax API ------------------------------------------------------------

void set_TargetCharacter(this Rellax*, Character* target)
{ 
  _set_targetcharacter(target);
}

Character* get_TargetCharacter(this Rellax*)
{
  return  _TargetCharacter;
}

void set_EnableParallax(this Rellax*, bool enable)
{ 
  _enable_parallax(enable);
}

bool get_EnableParallax(this Rellax*)
{
  return _ParallaxEnabled;
}

void set_DebugShow(this Rellax*, bool enable)
{ 
  _enable_debug_overlay(enable);
}

bool get_DebugShow(this Rellax*)
{
  return _DebugShow;
}

void set_EnableSmoothCam(this Rellax*, bool enable)
{ 
  _enable_smoothcam(enable);
}

bool get_EnableSmoothCam(this Rellax*)
{
  return _SmoothCamEnabled;
}

void set_AdjustCameraOnRoomLoad(this Rellax*, bool enable)
{ 
  _AdjustCameraOnRoomLoad = enable;
}

bool get_AdjustCameraOnRoomLoad(this Rellax*)
{
  return _AdjustCameraOnRoomLoad;
}

void set_CameraOffsetX(this Rellax*, int offset_x)
{ 
  _off_x = offset_x;
}

int get_CameraOffsetX(this Rellax*)
{
  return _off_x;
}

void set_CameraOffsetY(this Rellax*, int offset_y)
{ 
  _off_y = offset_y;
}

int get_CameraOffsetY(this Rellax*)
{
  return _off_y;
}

void set_CameraLookAheadX(this Rellax*, int look_ahead_x)
{ 
  _look_ahead_x = look_ahead_x;
}

int get_CameraLookAheadX(this Rellax*)
{
  return _look_ahead_x;
}

void set_CameraLookAheadY(this Rellax*, int look_ahead_y)
{ 
  _look_ahead_y = look_ahead_y;
}

int get_CameraLookAheadY(this Rellax*)
{
  return _look_ahead_y;
}

void set_StandstillCameraDelayY(this Rellax*, int value)
{ 
  _standstill_ticks_y = value;
}

int get_StandstillCameraDelayY(this Rellax*)
{
  return _standstill_ticks_y;
}

void set_CameraLerpFactorX(this Rellax*, float value)
{ 
  _cam_lerp_factor_x = value;
}

float get_CameraLerpFactorX(this Rellax*)
{
  return _cam_lerp_factor_x;
}

void set_CameraLerpFactorY(this Rellax*, float value)
{ 
  _cam_lerp_factor_y = value;
}

float get_CameraLerpFactorY(this Rellax*)
{
  return _cam_lerp_factor_y;
}

void set_CameraWindowWidth(this Rellax*, int value)
{ 
  _cam_window_w = value;
}

int get_CameraWindowWidth(this Rellax*)
{
  return _cam_window_w;
}

void set_CameraWindowHeight(this Rellax*, int value)
{ 
  _cam_window_h = value;
}

int get_CameraWindowHeight(this Rellax*)
{
  return _cam_window_h;
}

// ----------------------------------------------------------------------------

void doSetOrigins ()
{
  _pxo_count=0; // Reset the total number of parallax objects to zero
  float cam_w = IntToFloat(Game.Camera.Width);
  float cam_h = IntToFloat(Game.Camera.Height);
  float room_w = IntToFloat(Room.Width);
  float room_h = IntToFloat(Room.Height);

  for(int i=0; i<Room.ObjectCount; i++){
    if (object[i].GetProperty("PxPos")!=0) {
      // Store the object in the parallax object array
      _pxo[_pxo_count] = object[i];
      // Get the parallax values for the object, and it's position
      float parallax_x = IntToFloat(object[i].GetProperty("PxPos")) / 100.0;
      float parallax_y = IntToFloat(object[i].GetProperty("PyPos")) / 100.0;
      float obj_x = IntToFloat(object[i].X);
      float obj_y = IntToFloat(object[i].Y);
      // Store the object's initial position for resetting later
      _pxoRoomStartX[_pxo_count] = object[i].X;
      _pxoRoomStartY[_pxo_count] = object[i].Y;
      // Calculate the origin position for the object
      _pxoOriginX[_pxo_count] = object[i].X - FloatToInt(parallax_x * obj_x * (room_w - cam_w) / room_w);
      _pxoOriginY[_pxo_count] = object[i].Y - FloatToInt(parallax_y * obj_y * (room_h - cam_h) / room_h);

			if(_pxo_count<MAX_PARALLAX_OBJS) _pxo_count++;
		}
  }
  // Apply the parallax effect to the objects
  doObjectParallax();
}

void doRoomSetup()
{  
  Game.Camera.X = _ClampInt(_TargetCharacter.x-Game.Camera.Width/2, 
    0, Room.Width-Game.Camera.Width);

  Game.Camera.Y = _ClampInt(_TargetCharacter.y-Game.Camera.Height/2, 
    0, Room.Height-Game.Camera.Height);

  _updateCameras();
  doSetOrigins();


  if (_ParallaxEnabled) _enable_parallax(true);
  else _enable_parallax(false);
  _is_doRoomSetup = true;
}


// --- callbacks --------------------------------------------------------------

function on_event (EventType event, int data){
  // player exits any room
  if (event==eEventLeaveRoom){
    // reset the parallax object positions
    for(int i=0; i<_pxo_count; i++){
      _pxo[i].X=_pxoRoomStartX[i];
      _pxo[i].Y=_pxoRoomStartY[i];
    }
    _is_doRoomSetup = false;
  }

  // player enters a room that's different from current
	if (event==eEventEnterRoomBeforeFadein){    
    if(!_is_doRoomSetup){
      doRoomSetup();
    }
    
    if(_SmoothCamEnabled && _AdjustCameraOnRoomLoad) {
      _quickAdjustToTarget();
    }
  }
}

function game_start(){
  _TargetPos = new Point;
  System.VSync = true;
  _rellax_defaults();
}

function late_repeatedly_execute_always(){
  if(_SmoothCamEnabled) doSmoothCameraTracking();
  if(_ParallaxEnabled) doObjectParallax();
  if(_SmoothCamEnabled) {
    Game.Camera.SetAt(FloatToInt(_next_cam_x), FloatToInt(_next_cam_y));
    _cam_x = _next_cam_x;
    _cam_y = _next_cam_y;
  }
  else {
    _updateCameras();
  }
}

function repeatedly_execute_always(){
  _TargetPos.x = _TargetCharacter.x;
  _TargetPos.y = _TargetCharacter.y + _partial_c_height;
  
  if(_DebugShow) _drawDebugOverlay();
  if(!_is_doRoomSetup) doRoomSetup();
}
